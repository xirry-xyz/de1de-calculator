<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>de1de tracker</title>
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .card {
            background-color: #161b22;
            border: 1px solid #30363d;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .btn-primary {
            background-color: #238636;
            transition: background-color 0.2s;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #2ea043;
        }
        .input-field:disabled {
            background-color: #21262d;
            cursor: not-allowed;
        }
        .input-field {
            background-color: #0d1117;
            border-color: #30363d;
            color: #c9d1d9;
        }
        .table-header {
            background-color: #21262d;
            color: #f0f6fc;
        }
        .text-win { color: #2ea043; }
        .text-loss { color: #f85149; }
        .text-neutral { color: #c9d1d9; }
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .badge-admin { background-color: #f69d3c; color: #161b22; }
        .badge-private { background-color: #38a169; color: white; }
        
        /* Sortable Header Styles */
        th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }
        th.sortable:hover {
            background-color: #30363d;
        }
        th.sortable .sort-icon {
            margin-left: 4px;
            font-size: 0.8em;
            color: #8b949e;
        }
        th.sortable.active-sort {
            color: #58a6ff;
        }
    </style>
</head>
<body>

    <div class="min-h-screen p-4 sm:p-8">
        <h1 class="text-3xl font-bold mb-8 text-center text-white">ğŸ´ de1de tracker ğŸ“ˆ</h1>
        
        <!-- Auth Status & Button -->
        <div class="card p-4 rounded-xl mb-6 flex flex-col sm:flex-row justify-between items-start sm:items-center bg-gray-800/50">
            <div>
                <p id="auth-status" class="text-sm text-yellow-400 font-medium">æ­£åœ¨åˆå§‹åŒ–...</p>
                <p id="admin-status" class="text-xs mt-1 font-bold"></p>
                <p class="text-xs mt-1 text-gray-400">å½“å‰ç”¨æˆ·ID: <span id="user-id-display" class="font-mono text-gray-300">...</span></p>
            </div>
            <button id="auth-button" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg text-sm mt-3 sm:mt-0 opacity-50 cursor-not-allowed" disabled>
                åŠ è½½ä¸­...
            </button>
        </div>

        <!-- Session Configuration and New Player Input -->
        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">æœ¬å±€é…ç½®ä¸ç©å®¶æ•°æ®</h2>
            
            <!-- Session Meta (Name & Date) - NEW -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4 p-4 rounded-lg bg-gray-800/50">
                <div>
                    <label for="sessionName" class="block text-sm font-medium mb-1">ç‰Œå±€åç§° (é€‰å¡«)</label>
                    <input type="text" id="sessionName" class="input-field w-full p-2 rounded-lg border focus:ring-green-500 focus:border-green-500" placeholder="ä¾‹å¦‚: å‘¨äº”å…»ç”Ÿå±€">
                </div>
                <div>
                    <label for="sessionDate" class="block text-sm font-medium mb-1">ç‰Œå±€æ—¥æœŸ</label>
                    <!-- UPDATED: type="date" instead of datetime-local -->
                    <input type="date" id="sessionDate" class="input-field w-full p-2 rounded-lg border focus:ring-green-500 focus:border-green-500">
                </div>
            </div>

            <!-- Session Configuration (Per Game) -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6 p-4 rounded-lg bg-gray-800/50">
                <div>
                    <label for="chipsPerEntry" class="block text-sm font-medium mb-1">æ¯æ‰‹ä¹°å…¥ç­¹ç æ•° (æœ¬å±€)</label>
                    <input type="number" id="chipsPerEntry" value="3000" class="input-field w-full p-2 rounded-lg border focus:ring-green-500 focus:border-green-500" placeholder="ä¾‹å¦‚: 3000">
                </div>
                <div>
                    <label for="cnyPerEntry" class="block text-sm font-medium mb-1">æ¯æ‰‹ä¹°å…¥å¯¹åº” CNY (æœ¬å±€)</label>
                    <input type="number" id="cnyPerEntry" value="300" class="input-field w-full p-2 rounded-lg border focus:ring-green-500 focus:border-green-500" placeholder="ä¾‹å¦‚: 300">
                </div>
            </div>

            <!-- Player Input -->
            <div class="grid grid-cols-1 sm:grid-cols-4 gap-3">
                <div>
                    <label for="playerName" class="block text-sm font-medium mb-1">ç©å®¶å§“å</label>
                    <input type="text" id="playerName" class="input-field w-full p-2 rounded-lg border" placeholder="A, B, C, D..." disabled>
                </div>
                <div>
                    <label for="playerEntries" class="block text-sm font-medium mb-1">å‡€ä¹°å…¥æ¬¡æ•° (å¯ä¸ºè´Ÿ)</label>
                    <input type="number" id="playerEntries" value="2" class="input-field w-full p-2 rounded-lg border" placeholder="ä¾‹å¦‚: 2 æˆ– -1" disabled>
                </div>
                <div>
                    <label for="playerFinalChips" class="block text-sm font-medium mb-1">æœ€ç»ˆç­¹ç æ•°</label>
                    <input type="number" id="playerFinalChips" value="3000" class="input-field w-full p-2 rounded-lg border" placeholder="ä¾‹å¦‚: 3000" disabled>
                </div>
                <div class="flex items-end">
                    <button onclick="addPlayerToSession()" id="add-player-btn" class="btn-primary w-full p-2 rounded-lg font-semibold disabled:opacity-50 disabled:cursor-not-allowed" disabled>æ·»åŠ ç©å®¶</button>
                </div>
            </div>
        </div>

        <!-- Session Results and Transfers -->
        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">å½“å‰ç‰Œå±€ç»“ç®—</h2>
            
            <!-- Player Data Table -->
            <div class="overflow-x-auto mb-6">
                <table class="min-w-full divide-y divide-gray-700 rounded-lg overflow-hidden">
                    <thead class="table-header">
                        <tr>
                            <th class="p-3 text-left text-xs font-medium uppercase tracking-wider">ç©å®¶</th>
                            <th class="p-3 text-right text-xs font-medium uppercase tracking-wider">æ€»ä¹°å…¥ (ç­¹ç )</th>
                            <th class="p-3 text-right text-xs font-medium uppercase tracking-wider">æœ€ç»ˆç­¹ç </th>
                            <th class="p-3 text-right text-xs font-medium uppercase tracking-wider">P&L (ç­¹ç )</th>
                            <th class="p-3 text-right text-xs font-medium uppercase tracking-wider">P&L (CNY)</th>
                            <th class="p-3 text-right text-xs font-medium uppercase tracking-wider">è°ƒæ•´å P&L</th>
                            <th class="p-3 text-center text-xs font-medium uppercase tracking-wider">æ“ä½œ</th>
                        </tr>
                    </thead>
                    <tbody id="session-data-body" class="divide-y divide-gray-800">
                        <tr id="session-placeholder"><td colspan="7" class="p-4 text-center text-gray-400">è¯·æ·»åŠ ç©å®¶æ•°æ®...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Summary and Actions -->
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mt-4 p-4 rounded-lg bg-gray-800/50">
                <div class="text-sm">
                    <p>æ€»ä¹°å…¥ç­¹ç : <span id="total-buy-in" class="font-bold">0</span></p>
                    <p>æ€»å‰©ä½™ç­¹ç : <span id="total-final-chips" class="font-bold">0</span></p>
                    <p>ç­¹ç å·®é¢ (åº”ä¸º0): <span id="chip-discrepancy" class="font-bold">0</span></p>
                    <p>CNY ç›ˆäºæ€»å’Œ (åº”ä¸º0): <span id="cny-discrepancy" class="font-bold text-yellow-400">0 CNY</span></p>
                </div>
                <div class="mt-4 sm:mt-0 flex space-x-3">
                    <button onclick="calculateSettlement()" class="btn-primary p-3 rounded-lg font-semibold bg-gray-600 hover:bg-gray-700">è®¡ç®—è½¬è´¦æ–¹æ¡ˆ</button>
                    <button onclick="saveSessionData()" id="save-session-btn" class="btn-primary p-3 rounded-lg font-semibold bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>ä¿å­˜ç‰Œå±€</button>
                    <button onclick="clearSession()" id="clear-session-btn" class="p-3 rounded-lg font-semibold bg-red-600 hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed" disabled>æ¸…ç©º</button>
                </div>
            </div>
            
            <!-- Transfer Solution -->
            <div id="transfer-solution" class="mt-6 p-4 rounded-lg bg-green-900/30 border border-green-600 hidden">
                <h3 class="text-lg font-semibold mb-2" style="color: #48bb78;">ğŸ’¸ æœ€ä½³è½¬è´¦æ–¹æ¡ˆ (æœ€å°åŒ–æ¬¡æ•°)</h3>
                <ul id="transfer-list" class="space-y-1"></ul>
            </div>
        </div>
        
        <!-- Past Sessions List (Public) -->
        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">ğŸ“œ å†å²ç‰Œå±€è®°å½• <span class="badge badge-admin">å…¬å…±æ•°æ®</span></h2>
            <div class="flex justify-between items-center mb-4">
                <p class="text-sm text-gray-400">ç‚¹å‡»åˆ é™¤æŒ‰é’®å°†ä»å…¬å…±ç§¯åˆ†æ¦œä¸­æ°¸ä¹…ç§»é™¤è¯¥ç‰Œå±€æ•°æ®ã€‚</p>
                <button onclick="loadPastSessions()" class="p-2 rounded-lg font-semibold text-sm bg-gray-600 hover:bg-gray-700">åˆ·æ–°è®°å½•</button>
            </div>
            <div id="past-sessions-list" class="space-y-3">
                <p class="text-center text-gray-500" id="sessions-loading-status">æ­£åœ¨åŠ è½½å…¬å…±å†å²è®°å½•...</p>
            </div>
        </div>

        <!-- My Private Sessions List -->
        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">ğŸ”’ æˆ‘çš„ç§äººç‰Œå±€è®°å½• <span class="badge badge-private">ç§äººæ•°æ®</span></h2>
            <div class="flex justify-between items-center mb-4">
                <p class="text-sm text-gray-400">ç§äººæ•°æ®ä»…å¯¹å½“å‰ç™»å½•ç”¨æˆ·å¯è§ï¼Œä¸å½±å“å…¬å…±ç§¯åˆ†æ¦œã€‚</p>
                <button onclick="loadPrivateSessions()" class="p-2 rounded-lg font-semibold text-sm bg-gray-600 hover:bg-gray-700">åˆ·æ–°æˆ‘çš„è®°å½•</button>
            </div>
            <div id="private-sessions-list" class="space-y-3">
                <p class="text-center text-gray-500" id="private-sessions-loading-status">ç™»å½•åå¯æŸ¥çœ‹å’Œç¼–è¾‘æ‚¨çš„ç§äººç‰Œå±€ã€‚</p>
            </div>
        </div>

        <!-- Leaderboard (Scoreboard) (Public) -->
        <div class="card p-6 rounded-xl mb-8">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2 flex justify-between items-center">
                <span>ğŸ“Š æ€»ç§¯åˆ†æ¦œ <span class="badge badge-admin">å…¬å…± Leaderboard</span></span>
                <span class="text-xs text-gray-500 font-normal">ç‚¹å‡»è¡¨å¤´å¯æ’åº</span>
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-700 rounded-lg overflow-hidden">
                    <thead class="table-header">
                        <tr id="public-leaderboard-header">
                            <!-- Headers injected via JS to support sort icons -->
                        </tr>
                    </thead>
                    <tbody id="leaderboard-body" class="divide-y divide-gray-800">
                        <tr id="leaderboard-placeholder"><td colspan="9" class="p-4 text-center text-gray-400">åŠ è½½ä¸­... è¯·ç¡®ä¿å·²ä¿å­˜å…¬å…±ç‰Œå±€æ•°æ®ã€‚</td></tr>
                    </tbody>
                </table>
            </div>
            <button onclick="loadPublicScoreboard()" class="btn-primary mt-4 p-2 rounded-lg font-semibold bg-gray-600 hover:bg-gray-700">åˆ·æ–°å…¬å…±ç§¯åˆ†æ¦œ</button>
        </div>
        
        <!-- My Private Leaderboard -->
        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2 flex justify-between items-center">
                <span>ğŸ‘¤ æˆ‘çš„ç§äººç§¯åˆ†æ¦œ <span class="badge badge-private">ç§äºº Leaderboard</span></span>
                <span class="text-xs text-gray-500 font-normal">ç‚¹å‡»è¡¨å¤´å¯æ’åº</span>
            </h2>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-700 rounded-lg overflow-hidden">
                    <thead class="table-header">
                        <tr id="private-leaderboard-header">
                            <!-- Headers injected via JS to support sort icons -->
                        </tr>
                    </thead>
                    <tbody id="private-leaderboard-body" class="divide-y divide-gray-800">
                        <tr id="private-leaderboard-placeholder"><td colspan="9" class="p-4 text-center text-gray-400">ç™»å½•åå¯æŸ¥çœ‹æ‚¨çš„ç§äººç§¯åˆ†æ¦œã€‚</td></tr>
                    </tbody>
                </table>
            </div>
            <button onclick="loadPrivateScoreboard()" class="btn-primary mt-4 p-2 rounded-lg font-semibold bg-gray-600 hover:bg-gray-700">åˆ·æ–°ç§äººç§¯åˆ†æ¦œ</button>
        </div>

    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, doc, setDoc, getDoc, deleteDoc, getDocs, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const ADMIN_EMAIL = 'xirry.xyz@gmail.com'; 
        let isAdmin = false; 

        let db;
        let auth;
        let userId = 'anonymous'; 

        let sessionPlayers = [];
        
        // Data Cache for Sorting
        let publicLeaderboardData = [];
        let privateLeaderboardData = [];
        
        // Sorting State
        let sortState = {
            public: { column: 'score', direction: 'desc' },
            private: { column: 'score', direction: 'desc' }
        };

        const MANUAL_FIREBASE_CONFIG = {
            apiKey: "***REMOVED***", 
            authDomain: "de1de-calculator.firebaseapp.com",
            projectId: "de1de-calculator",
            storageBucket: "de1de-calculator.firebasestorage.app",
            messagingSenderId: "1076456073032",
            appId: "1:1076456073032:web:5402bb2cb74e6940bf757d"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : MANUAL_FIREBASE_CONFIG.projectId;
        const firebaseConfig = 
            typeof __firebase_config !== 'undefined' && __firebase_config.length > 0
            ? JSON.parse(__firebase_config) 
            : MANUAL_FIREBASE_CONFIG;
        
        // Expose global functions
        window.addPlayerToSession = addPlayerToSession;
        window.removePlayer = removePlayer;
        window.calculateSettlement = calculateSettlement;
        window.saveSessionData = saveSessionData;
        window.clearSession = clearSession;
        window.calculateTransfers = calculateTransfers; 
        window.deleteSession = deleteSession;
        window.signInWithGoogle = signInWithGoogle;
        window.signOutUser = signOutUser;
        window.loadPublicScoreboard = () => loadScoreboard(true);
        window.loadPrivateScoreboard = () => loadScoreboard(false);
        window.loadPastSessions = () => loadSessions(true);
        window.loadPrivateSessions = () => loadSessions(false);
        window.toggleSort = toggleSort;

        // --- Core Functions ---
        function getCurrentSessionConfig() {
            const chips = parseFloat(document.getElementById('chipsPerEntry').value);
            const cny = parseFloat(document.getElementById('cnyPerEntry').value);
            if (isNaN(chips) || chips <= 0 || isNaN(cny) || cny <= 0) return null;
            return { chipsPerEntry: chips, cnyPerEntry: cny };
        }

        function getPublicCollection(collectionName) {
            return collection(db, `artifacts/${appId}/public/data/${collectionName}`);
        }
        
        function getPrivateCollection(collectionName) {
            if (userId === 'anonymous' || !db) return null; 
            return collection(db, `artifacts/${appId}/users/${userId}/${collectionName}`);
        }

        function toggleEditingUI(canEdit) {
            const sessionInputElements = ['playerName', 'playerEntries', 'playerFinalChips', 'add-player-btn', 'chipsPerEntry', 'cnyPerEntry', 'sessionName', 'sessionDate'];
            sessionInputElements.forEach(id => { const el = document.getElementById(id); if (el) el.disabled = !canEdit; });
            const sessionActionElements = ['save-session-btn', 'clear-session-btn'];
            sessionActionElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.disabled = !canEdit;
                    if (el.tagName === 'BUTTON') {
                        el.classList.toggle('opacity-50', !canEdit);
                        el.classList.toggle('cursor-not-allowed', !canEdit);
                    }
                }
            });
            updateSessionSummary();
        }

        async function signInWithGoogle() {
            if (!auth) return;
            const provider = new GoogleAuthProvider();
            try {
                provider.setCustomParameters({ prompt: 'select_account' });
                await signInWithPopup(auth, provider);
            } catch (error) {
                alertModal("ç™»å½•å¤±è´¥", error.message + "\n\næç¤º: å¦‚æœæ‚¨åœ¨ Vercel ä¸Šéƒ¨ç½²ï¼Œè¯·ç¡®ä¿å·²åœ¨ Firebase æ§åˆ¶å°çš„ Auth -> Settings -> Authorized Domains ä¸­æ·»åŠ äº†æ‚¨çš„ Vercel åŸŸåã€‚");
            }
        }

        async function signOutUser() {
            if (!auth) return;
            try { 
                await signOut(auth); 
                alertModal("æ“ä½œæˆåŠŸ", "æ‚¨å·²æˆåŠŸé€€å‡ºç™»å½•ã€‚"); 
            } catch (error) { alertModal("æ“ä½œå¤±è´¥", error.message); }
        }

        async function initializeFirebase() {
            // Initialize Date input to YYYY-MM-DD local time
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            document.getElementById('sessionDate').value = `${yyyy}-${mm}-${dd}`;

            if (firebaseConfig.apiKey === 'REPLACE_WITH_YOUR_API_KEY') {
                document.getElementById('auth-status').textContent = 'é”™è¯¯: è¯·åœ¨ä»£ç ä¸­æ›¿æ¢ API å¯†é’¥åå†éƒ¨ç½²ã€‚';
                return;
            }
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // If there is an initial custom token (e.g. from Canvas environment), use it.
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } catch (e) {
                        console.error("Custom token auth failed:", e);
                    }
                }
                
                onAuthStateChanged(auth, (user) => {
                    const authButton = document.getElementById('auth-button');
                    const authStatus = document.getElementById('auth-status');
                    const adminStatus = document.getElementById('admin-status');
                    const userIdDisplay = document.getElementById('user-id-display');

                    // Unlock button in all cases
                    authButton.disabled = false;
                    authButton.classList.remove('opacity-50', 'cursor-not-allowed');

                    if (user) {
                        // User is authenticated
                        userId = user.uid;
                        const isAnon = user.isAnonymous;
                        const email = user.email;
                        
                        // Check Admin
                        let currentIsAdmin = false;
                        if (!isAnon && email === ADMIN_EMAIL) {
                            currentIsAdmin = true;
                        }
                        isAdmin = currentIsAdmin;

                        // UI Logic
                        userIdDisplay.textContent = userId;
                        
                        if (isAnon) {
                            // Guest / Anonymous Mode (if enabled)
                            authStatus.textContent = 'è®¿å®¢æ¨¡å¼ (åªè¯»)';
                            adminStatus.textContent = 'ğŸ”’ è¯·ç™»å½•ä»¥ç¼–è¾‘æ•°æ®æˆ–æŸ¥çœ‹ç§äººè®°å½•ã€‚';
                            adminStatus.classList.add('text-yellow-400');
                            adminStatus.classList.remove('text-green-400', 'text-red-400');
                            
                            authButton.textContent = 'ä½¿ç”¨ Google ç™»å½•';
                            authButton.onclick = signInWithGoogle;
                            authButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
                            authButton.classList.remove('bg-gray-600', 'hover:bg-gray-700');

                            loadScoreboard(true);
                            loadSessions(true);
                            
                            toggleEditingUI(false);

                        } else {
                            // Full User Mode
                            authStatus.textContent = `å½“å‰ç”¨æˆ·: ${email}`;
                            authButton.textContent = 'é€€å‡ºç™»å½•';
                            authButton.onclick = signOutUser;
                            authButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                            authButton.classList.add('bg-gray-600', 'hover:bg-gray-700');
                            
                            if (isAdmin) {
                                adminStatus.textContent = 'ğŸ‘‘ æ‚¨æ˜¯ç®¡ç†å‘˜ï¼Œæ‹¥æœ‰å…¬å…±æ•°æ®ç¼–è¾‘å’Œåˆ é™¤æƒé™ã€‚';
                                adminStatus.classList.remove('text-yellow-400', 'text-red-400');
                                adminStatus.classList.add('text-green-400');
                            } else {
                                adminStatus.textContent = 'ğŸ”’ æ‚¨æ˜¯æ™®é€šç”¨æˆ·ï¼Œåªèƒ½ç¼–è¾‘å’ŒæŸ¥çœ‹æ‚¨çš„ç§äººç‰Œå±€ã€‚';
                                adminStatus.classList.add('text-yellow-400');
                                adminStatus.classList.remove('text-green-400', 'text-red-400');
                            }

                            loadScoreboard(true); 
                            loadSessions(true); 
                            loadScoreboard(false); 
                            loadSessions(false); 
                            
                            toggleEditingUI(true); 
                        }

                    } else {
                        // Not Logged In (Guest without Anon Auth)
                        userId = 'anonymous';
                        isAdmin = false;
                        
                        authStatus.textContent = 'æœªç™»å½• (è®¿å®¢æ¨¡å¼)';
                        adminStatus.textContent = 'ğŸ”’ æ­£åœ¨æŸ¥çœ‹å…¬å…±æ•°æ®ã€‚ç™»å½•åå¯ç¼–è¾‘ã€‚';
                        adminStatus.classList.add('text-yellow-400');
                        userIdDisplay.textContent = 'N/A';
                        
                        authButton.textContent = 'ä½¿ç”¨ Google ç™»å½•';
                        authButton.onclick = signInWithGoogle;
                        authButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
                        
                        // Try to load public data anyway (assuming Firestore rules allow public read)
                        loadScoreboard(true);
                        loadSessions(true);
                        
                        // Disable UI
                        toggleEditingUI(false);
                    }
                });
            } catch (error) {
                console.error("Firebase Init Failed:", error);
                document.getElementById('auth-status').textContent = 'åˆå§‹åŒ–é”™è¯¯: ' + error.message;
            }
        }
        
        function addPlayerToSession() {
            // Check auth state properly
            if (!auth.currentUser || auth.currentUser.isAnonymous) { 
                alertModal("æ“ä½œå¤±è´¥", "è¯·å…ˆç™»å½•æ‰èƒ½æ·»åŠ ç©å®¶æ•°æ®ã€‚"); 
                return; 
            }
            
            const currentConfig = getCurrentSessionConfig();
            if (!currentConfig) { alertModal("è¾“å…¥é”™è¯¯", "é…ç½®æ— æ•ˆã€‚"); return; }

            const name = document.getElementById('playerName').value.trim();
            const entries = parseFloat(document.getElementById('playerEntries').value);
            const finalChips = parseFloat(document.getElementById('playerFinalChips').value);

            if (!name || isNaN(entries) || isNaN(finalChips) || finalChips < 0) {
                alertModal("è¾“å…¥é”™è¯¯", "è¯·æ£€æŸ¥è¾“å…¥æ•°æ®ã€‚");
                return;
            }
            
            const totalBuyInChips = entries * currentConfig.chipsPerEntry;
            const pnlChips = finalChips - totalBuyInChips;
            const pnlCNY = pnlChips * (currentConfig.cnyPerEntry / currentConfig.chipsPerEntry);

            const existingIndex = sessionPlayers.findIndex(p => p.name === name);
            const newPlayer = {
                id: Date.now() + Math.random(),
                name, entries,
                totalBuyInChips: Math.round(totalBuyInChips),
                finalChips: Math.round(finalChips),
                pnlChips: Math.round(pnlChips),
                pnlCNY: parseFloat(pnlCNY.toFixed(2)),
                adjustedPnLCNY: parseFloat(pnlCNY.toFixed(2)),
                sessionConfig: currentConfig
            };

            if (existingIndex !== -1) sessionPlayers[existingIndex] = newPlayer;
            else sessionPlayers.push(newPlayer);

            document.getElementById('playerName').value = '';
            document.getElementById('playerEntries').value = '2';
            document.getElementById('playerFinalChips').value = '3000';
            updateSessionSummary();
        }
        
        function removePlayer(id) {
            if (!auth.currentUser || auth.currentUser.isAnonymous) return;
            sessionPlayers = sessionPlayers.filter(p => p.id !== id);
            updateSessionSummary();
        }

        function adjustDiscrepancy(players) {
            let totalPnL = players.reduce((sum, p) => sum + p.pnlCNY, 0);
            if (Math.abs(totalPnL) < 0.01) return players.map(p => ({ ...p, adjustedPnLCNY: p.pnlCNY }));

            const adjustedPlayers = players.map(p => ({ ...p, adjustedPnLCNY: p.pnlCNY }));
            const adjustmentMagnitude = Math.abs(totalPnL); 

            if (totalPnL > 0) { 
                const winners = adjustedPlayers.filter(p => p.adjustedPnLCNY > 0);
                const totalWinMagnitude = winners.reduce((sum, p) => sum + p.adjustedPnLCNY, 0);
                if (totalWinMagnitude > 0) winners.forEach(p => { p.adjustedPnLCNY -= adjustmentMagnitude * (p.adjustedPnLCNY / totalWinMagnitude); });
            } else { 
                const losers = adjustedPlayers.filter(p => p.adjustedPnLCNY < 0);
                const totalLossMagnitude = losers.reduce((sum, p) => sum + Math.abs(p.adjustedPnLCNY), 0);
                if (totalLossMagnitude > 0) losers.forEach(p => { p.adjustedPnLCNY += adjustmentMagnitude * (Math.abs(p.adjustedPnLCNY) / totalLossMagnitude); });
            }
            return adjustedPlayers.map(p => ({ ...p, adjustedPnLCNY: parseFloat(p.adjustedPnLCNY.toFixed(2)) }));
        }

        function updateSessionSummary() {
            sessionPlayers = adjustDiscrepancy(sessionPlayers.map(p => ({ ...p, pnlCNY: p.pnlCNY })));
            const tbody = document.getElementById('session-data-body');
            const saveBtn = document.getElementById('save-session-btn');
            tbody.innerHTML = '';
            
            let totalBuyInChips = 0, totalFinalChips = 0, totalPnLCNY = 0;
            // Check edit permission based on auth state
            const isEditingEnabled = auth && auth.currentUser && !auth.currentUser.isAnonymous;

            if (sessionPlayers.length === 0) {
                tbody.innerHTML = '<tr id="session-placeholder"><td colspan="7" class="p-4 text-center text-gray-400">è¯·æ·»åŠ ç©å®¶æ•°æ®...</td></tr>';
                saveBtn.disabled = true;
                document.getElementById('clear-session-btn').disabled = true;
            } else {
                saveBtn.disabled = !isEditingEnabled;
                document.getElementById('clear-session-btn').disabled = !isEditingEnabled;
                sessionPlayers.forEach(p => {
                    totalBuyInChips += p.totalBuyInChips;
                    totalFinalChips += p.finalChips;
                    totalPnLCNY += p.adjustedPnLCNY;
                    const pnlClass = p.adjustedPnLCNY > 0.01 ? 'text-win' : p.adjustedPnLCNY < -0.01 ? 'text-loss' : 'text-neutral';
                    const removeBtnHtml = isEditingEnabled ? `<button onclick="removePlayer(${p.id})" class="text-red-500 hover:text-red-400 text-sm font-semibold">ç§»é™¤</button>` : `<span class="text-gray-600 text-sm cursor-not-allowed">é”å®š</span>`;
                    tbody.innerHTML += `<tr class="hover:bg-gray-800/70 transition-colors"><td class="p-3 font-semibold">${p.name}</td><td class="p-3 text-right">${p.totalBuyInChips}</td><td class="p-3 text-right">${p.finalChips}</td><td class="p-3 text-right ${pnlClass}">${p.pnlChips}</td><td class="p-3 text-right ${pnlClass}">${p.pnlCNY.toFixed(2)} CNY</td><td class="p-3 text-right ${pnlClass} font-bold">${p.adjustedPnLCNY.toFixed(2)} CNY</td><td class="p-3 text-center">${removeBtnHtml}</td></tr>`;
                });
            }

            document.getElementById('total-buy-in').textContent = Math.round(totalBuyInChips);
            document.getElementById('total-final-chips').textContent = Math.round(totalFinalChips);
            document.getElementById('chip-discrepancy').textContent = Math.round(totalFinalChips - totalBuyInChips);
            const cnyDiscrepancyElement = document.getElementById('cny-discrepancy');
            cnyDiscrepancyElement.textContent = `${totalPnLCNY.toFixed(2)} CNY`;
            cnyDiscrepancyElement.className = totalPnLCNY > 0.01 ? 'font-bold text-win' : totalPnLCNY < -0.01 ? 'font-bold text-loss' : 'font-bold text-green-400';
            
            if (document.getElementById('transfer-solution').classList.contains('block')) calculateSettlement();
        }
        
        function calculateSettlement() {
            if (sessionPlayers.length === 0) { alertModal("ç»“ç®—å¤±è´¥", "è¯·å…ˆæ·»åŠ ç©å®¶æ•°æ®ã€‚"); return; }
            const transfers = calculateTransfers(sessionPlayers.map(p => ({ name: p.name, pnl: p.adjustedPnLCNY })));
            const transferList = document.getElementById('transfer-list');
            const solutionDiv = document.getElementById('transfer-solution');
            transferList.innerHTML = '';
            if (transfers.length === 0) transferList.innerHTML = `<li class="text-green-300">ğŸ‰ æ‰€æœ‰ç©å®¶ç›ˆäºä¸ºé›¶ï¼Œæ— éœ€è½¬è´¦ï¼</li>`;
            else transfers.forEach(t => { transferList.innerHTML += `<li><span class="font-bold">${t.from}</span> â†’ <span class="font-bold">${t.to}</span>: <span class="text-green-300">${t.amount.toFixed(2)} CNY</span></li>`; });
            solutionDiv.classList.remove('hidden'); solutionDiv.classList.add('block');
        }

        function calculateTransfers(players) {
            const transfers = [];
            let winners = players.filter(p => p.pnl > 0).map(p => ({ ...p, pnl: parseFloat(p.pnl.toFixed(2)) })).sort((a, b) => b.pnl - a.pnl);
            let losers = players.filter(p => p.pnl < 0).map(p => ({ ...p, pnl: parseFloat(p.pnl.toFixed(2)) })).sort((a, b) => a.pnl - b.pnl);
            while (winners.length > 0 && losers.length > 0) {
                const winner = winners[0], loser = losers[0];
                const amount = Math.min(Math.abs(loser.pnl), winner.pnl);
                transfers.push({ from: loser.name, to: winner.name, amount: amount });
                winner.pnl -= amount; loser.pnl += amount;
                if (Math.abs(winner.pnl) < 0.01) winners.shift();
                if (Math.abs(loser.pnl) < 0.01) losers.shift();
            }
            return transfers;
        }

        async function saveSessionData() {
            if (!auth.currentUser || auth.currentUser.isAnonymous) { alertModal("ä¿å­˜å¤±è´¥", "è¯·å…ˆç™»å½•ã€‚"); return; }
            if (sessionPlayers.length === 0) { alertModal("ä¿å­˜å¤±è´¥", "æ²¡æœ‰ç©å®¶æ•°æ®ã€‚"); return; }
            const currentConfig = getCurrentSessionConfig();
            if (!currentConfig) { alertModal("ä¿å­˜å¤±è´¥", "é…ç½®æ— æ•ˆã€‚"); return; }

            const sessionName = document.getElementById('sessionName').value.trim() || 'æœªå‘½åç‰Œå±€';
            const sessionDateVal = document.getElementById('sessionDate').value;
            // UPDATED: Append T00:00:00 to force local date parsing, preventing previous-day issues in some TZs
            const sessionDate = sessionDateVal ? new Date(sessionDateVal + 'T00:00:00').toISOString() : new Date().toISOString();

            const isSavingPublic = isAdmin;
            const sessionsCol = isSavingPublic ? getPublicCollection('sessions') : getPrivateCollection('private-sessions');
            const scoreboardCol = isSavingPublic ? getPublicCollection('scoreboard') : getPrivateCollection('private-scoreboard');
            const successMessage = isSavingPublic ? 'å…¬å…±ç‰Œå±€' : 'ç§äººç‰Œå±€';
            const loadFunc = isSavingPublic ? () => { window.loadPublicScoreboard(); window.loadPastSessions(); } : () => { window.loadPrivateScoreboard(); window.loadPrivateSessions(); };

            if (!sessionsCol || !scoreboardCol) { alertModal("ä¿å­˜å¤±è´¥", "æ— æ³•è·å–å­˜å‚¨è·¯å¾„ã€‚"); return; }

            const sessionId = Date.now().toString();
            const sessionData = { 
                id: sessionId, 
                date: sessionDate, // Use user selected date
                name: sessionName, // Save session name
                config: currentConfig, 
                playerResults: sessionPlayers.map(p => ({ name: p.name, pnlCNY: p.adjustedPnLCNY, isWin: p.adjustedPnLCNY > 0.01 })) 
            };

            try {
                await setDoc(doc(sessionsCol, sessionId), sessionData);
                await runTransaction(db, async (transaction) => {
                    const updates = new Map();
                    for (const player of sessionPlayers) {
                        const playerRef = doc(scoreboardCol, player.name);
                        const docSnapshot = await transaction.get(playerRef);
                        let history = [];
                        if (docSnapshot.exists()) {
                            const data = docSnapshot.data();
                            if (data.history && Array.isArray(data.history)) history = data.history.filter(h => h.sessionId !== sessionId);
                        }
                        history.push({ sessionId: sessionId, date: sessionData.date, pnl: player.adjustedPnLCNY });
                        updates.set(player.name, { ref: playerRef, data: { name: player.name, history: history } });
                    }
                    for (const update of updates.values()) transaction.set(update.ref, update.data, { merge: true });
                });
                alertModal("ä¿å­˜æˆåŠŸ", `${successMessage}å·²ä¿å­˜ã€‚`);
                clearSession();
                // Reset session meta to today YYYY-MM-DD
                document.getElementById('sessionName').value = '';
                const now = new Date();
                const yyyy = now.getFullYear();
                const mm = String(now.getMonth() + 1).padStart(2, '0');
                const dd = String(now.getDate()).padStart(2, '0');
                document.getElementById('sessionDate').value = `${yyyy}-${mm}-${dd}`;
                
                loadFunc();
            } catch (e) {
                console.error(e);
                alertModal("ä¿å­˜å¤±è´¥", e.message);
            }
        }

        function clearSession() {
            if (!auth.currentUser || auth.currentUser.isAnonymous) return;
            sessionPlayers = [];
            document.getElementById('transfer-solution').classList.add('hidden');
            updateSessionSummary();
        }

        async function loadSessions(isPublic = true) {
            const sessionsCol = isPublic ? getPublicCollection('sessions') : getPrivateCollection('private-sessions');
            const listId = isPublic ? 'past-sessions-list' : 'private-sessions-list';
            const statusId = isPublic ? 'sessions-loading-status' : 'private-sessions-loading-status';
            const div = document.getElementById(listId);
            if (!div) return;
            
            if (!db || (!isPublic && (userId === 'anonymous' || (auth.currentUser && auth.currentUser.isAnonymous))) || (!sessionsCol && !isPublic)) {
                // For public data without login, we still try to fetch if we have a DB instance
                if (!isPublic) {
                    document.getElementById(statusId).textContent = "æ•°æ®æ— æ³•åŠ è½½ã€‚";
                    return;
                }
            }
            
            try {
                const snapshot = await getDocs(sessionsCol);
                const sessions = [];
                snapshot.forEach(doc => sessions.push({ id: doc.id, ...doc.data() }));
                sessions.sort((a, b) => new Date(b.date) - new Date(a.date));
                div.innerHTML = sessions.length === 0 ? `<p class="text-center text-gray-500">æš‚æ— è®°å½•ã€‚</p>` : '';
                
                sessions.forEach(session => {
                    // UPDATED: Show Date only (YYYY/MM/DD) without time
                    const date = new Date(session.date).toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
                    const displayName = session.name || 'æœªå‘½åç‰Œå±€';
                    const summary = session.playerResults.map(p => `<span class="${p.pnlCNY > 0 ? 'text-win' : p.pnlCNY < 0 ? 'text-loss' : 'text-neutral'}">${p.name}(${p.pnlCNY})</span>`).join(', ');
                    
                    // Check delete permissions
                    const isAnon = auth.currentUser && auth.currentUser.isAnonymous;
                    const canDelete = (isPublic && isAdmin) || (!isPublic && !isAnon && userId !== 'anonymous');
                    
                    const escaped = JSON.stringify(session.playerResults).replace(/"/g, '&quot;');
                    const deleteBtn = canDelete ? `<button onclick="deleteSession('${session.id}', '${escaped}', ${isPublic})" class="px-2 py-1 rounded bg-red-900/50 hover:bg-red-800 text-xs text-red-200 ml-2 flex-shrink-0">åˆ é™¤</button>` : '';
                    div.innerHTML += `
                        <div class="p-3 mb-2 rounded border border-gray-700 bg-gray-800/40 flex justify-between items-start">
                            <div class="flex-grow mr-2">
                                <div class="flex flex-wrap items-baseline gap-2">
                                    <span class="text-base font-semibold text-white">${displayName}</span>
                                    <span class="text-xs text-gray-400 font-mono">${date}</span>
                                </div>
                                <div class="text-sm mt-1 leading-relaxed">${summary}</div>
                            </div>
                            ${deleteBtn}
                        </div>`;
                });
            } catch (e) {
                div.innerHTML = `<p class="text-center text-red-400">é”™è¯¯: ${e.message}</p>`;
            }
        }

        async function deleteSession(sessionId, playerResultsString, isPublic = true) {
            const playerResults = JSON.parse(playerResultsString.replace(/&quot;/g, '"'));
            const isAnon = auth.currentUser && auth.currentUser.isAnonymous;
            if ((isPublic && !isAdmin) || (!isPublic && (isAnon || userId === 'anonymous'))) { alertModal("å¤±è´¥", "æ— æƒåˆ é™¤ã€‚"); return; }
            
            const sessionsCol = isPublic ? getPublicCollection('sessions') : getPrivateCollection('private-sessions');
            const scoreboardCol = isPublic ? getPublicCollection('scoreboard') : getPrivateCollection('private-scoreboard');
            const sessionRef = doc(sessionsCol, sessionId);

            if (confirm(`ç¡®å®šè¦æ°¸ä¹…åˆ é™¤ ${isPublic ? 'å…¬å…±' : 'ç§äºº'} ç‰Œå±€å—ï¼Ÿ`)) {
                try {
                    await runTransaction(db, async (transaction) => {
                        const updates = new Map();
                        for (const result of playerResults) {
                            const playerRef = doc(scoreboardCol, result.name);
                            const docSnapshot = await transaction.get(playerRef);
                            if (docSnapshot.exists()) {
                                const data = docSnapshot.data();
                                const updatedHistory = (data.history || []).filter(h => h.sessionId !== sessionId);
                                updates.set(result.name, { ref: playerRef, data: { name: result.name, history: updatedHistory } });
                            }
                        }
                        for (const update of updates.values()) transaction.set(update.ref, update.data, { merge: true });
                        transaction.delete(sessionRef);
                    });
                    alertModal("æˆåŠŸ", "å·²åˆ é™¤ã€‚");
                    (isPublic ? window.loadPublicScoreboard : window.loadPrivateScoreboard)();
                    (isPublic ? window.loadPastSessions : window.loadPrivateSessions)();
                } catch (e) {
                    alertModal("é”™è¯¯", e.message);
                }
            }
        }

        // --- Scoreboard Sorting and Logic ---

        async function loadScoreboard(isPublic = true) {
            const scoreboardCol = isPublic ? getPublicCollection('scoreboard') : getPrivateCollection('private-scoreboard');
            const placeholder = document.getElementById(isPublic ? 'leaderboard-placeholder' : 'private-leaderboard-placeholder');
            
            if (!db || (!isPublic && (userId === 'anonymous' || (auth.currentUser && auth.currentUser.isAnonymous))) || (!scoreboardCol && !isPublic)) {
                if (!isPublic) {
                    if (placeholder) placeholder.textContent = "æ— æ³•åŠ è½½ã€‚";
                    return;
                }
            }

            try {
                const snapshot = await getDocs(scoreboardCol);
                const allHistory = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.history && Array.isArray(data.history)) data.history.forEach(h => allHistory.push({ name: data.name, ...h }));
                });

                const groupedHistory = allHistory.reduce((acc, item) => {
                    if (!acc[item.name]) acc[item.name] = [];
                    acc[item.name].push(item);
                    return acc;
                }, {});

                let stats = [];
                for (const name in groupedHistory) {
                    stats.push(calculateMetrics(name, groupedHistory[name]));
                }
                
                // Calculate Composite Score for all players
                stats = calculateCompositeScores(stats);

                // Cache data
                if (isPublic) publicLeaderboardData = stats;
                else privateLeaderboardData = stats;

                renderLeaderboard(isPublic);
            } catch (e) {
                console.error(e);
                if (placeholder) placeholder.textContent = "åŠ è½½å¤±è´¥æˆ–æ— æƒé™ã€‚";
            }
        }

        /**
         * Calculate composite score based on weights
         */
        function calculateCompositeScores(stats) {
            if (stats.length === 0) return [];

            // Helper for normalization (0-1 range)
            const normalize = (val, min, max) => (max === min) ? 0.5 : (val - min) / (max - min);
            
            // 1. Find Min/Max for each metric
            const metrics = {
                sharpe: { min: Infinity, max: -Infinity },
                avgPnL: { min: Infinity, max: -Infinity },
                winRate: { min: Infinity, max: -Infinity },
                totalSessions: { min: Infinity, max: -Infinity },
                maxLosingStreak: { min: Infinity, max: -Infinity }
            };

            stats.forEach(s => {
                // Handle Sharpe Infinity case (cap it at 5 or max finite + 1)
                let sVal = s.sharpe;
                if (!isFinite(sVal)) sVal = s.avgPnL > 0 ? 5 : -1; 
                s.safeSharpe = sVal;

                metrics.sharpe.min = Math.min(metrics.sharpe.min, s.safeSharpe);
                metrics.sharpe.max = Math.max(metrics.sharpe.max, s.safeSharpe);
                
                metrics.avgPnL.min = Math.min(metrics.avgPnL.min, s.avgPnL);
                metrics.avgPnL.max = Math.max(metrics.avgPnL.max, s.avgPnL);
                
                metrics.winRate.min = Math.min(metrics.winRate.min, s.winRate);
                metrics.winRate.max = Math.max(metrics.winRate.max, s.winRate);

                metrics.totalSessions.min = Math.min(metrics.totalSessions.min, s.totalSessions);
                metrics.totalSessions.max = Math.max(metrics.totalSessions.max, s.totalSessions);

                metrics.maxLosingStreak.min = Math.min(metrics.maxLosingStreak.min, s.maxLosingStreak);
                metrics.maxLosingStreak.max = Math.max(metrics.maxLosingStreak.max, s.maxLosingStreak);
            });

            // 2. Weights
            const W = {
                sharpe: 0.35,
                avgPnL: 0.25,
                winRate: 0.20,
                sessions: 0.10,
                losingStreak: -0.10 // Negative weight (lower is better)
            };

            // 3. Calculate Score
            return stats.map(s => {
                const normSharpe = normalize(s.safeSharpe, metrics.sharpe.min, metrics.sharpe.max);
                const normAvgPnL = normalize(s.avgPnL, metrics.avgPnL.min, metrics.avgPnL.max);
                const normWinRate = normalize(s.winRate, metrics.winRate.min, metrics.winRate.max);
                const normSessions = normalize(s.totalSessions, metrics.totalSessions.min, metrics.totalSessions.max);
                const normStreak = normalize(s.maxLosingStreak, metrics.maxLosingStreak.min, metrics.maxLosingStreak.max);
                
                // Base score 50 + weighted adjustments (scaled to roughly 0-100)
                // We multiply normalized values by 100 to get points
                let rawScore = (
                    (normSharpe * 100 * W.sharpe) +
                    (normAvgPnL * 100 * W.avgPnL) +
                    (normWinRate * 100 * W.winRate) +
                    (normSessions * 100 * W.sessions) +
                    (normStreak * 100 * W.losingStreak) 
                );
                
                // Adjust base so the worst player isn't negative or too low, best is near 100
                // Simple scaling: Map raw scores to 40-99 range usually looks good
                s.score = rawScore;
                return s;
            }).map(s => {
               // Re-normalize final scores to 50-99 for aesthetics
               // This is purely for display "nice-ness"
               return s;
            });
        }

        function calculateMetrics(name, history) {
            const pnls = history.map(h => h.pnl);
            const totalSessions = pnls.length;
            if (totalSessions === 0) return { name, totalSessions: 0, totalPnL: 0, avgPnL: 0, winRate: 0, volatility: 0, sharpe: 0, maxLosingStreak: 0, score: 0 };

            const totalPnL = pnls.reduce((sum, pnl) => sum + pnl, 0);
            const avgPnL = totalPnL / totalSessions;
            const variance = pnls.reduce((sum, pnl) => sum + Math.pow(pnl - avgPnL, 2), 0) / totalSessions;
            const volatility = Math.sqrt(variance);
            const sharpe = volatility > 0 ? avgPnL / volatility : (avgPnL > 0 ? Infinity : 0);
            const sessionsWon = pnls.filter(pnl => pnl > 0.01).length;
            const winRate = (sessionsWon / totalSessions) * 100;

            let currentLosingStreak = 0, maxLosingStreak = 0;
            for (const pnl of pnls) {
                if (pnl < -0.01) currentLosingStreak++;
                else currentLosingStreak = 0;
                maxLosingStreak = Math.max(maxLosingStreak, currentLosingStreak);
            }

            return { name, totalSessions, totalPnL, avgPnL, winRate, volatility, sharpe, maxLosingStreak };
        }

        function toggleSort(isPublicStr, column) {
            const isPublic = (isPublicStr === 'true');
            const state = isPublic ? sortState.public : sortState.private;
            
            if (state.column === column) {
                state.direction = state.direction === 'asc' ? 'desc' : 'asc';
            } else {
                state.column = column;
                state.direction = 'desc'; // Default desc for new column (usually better for stats)
            }
            renderLeaderboard(isPublic);
        }

        function renderLeaderboard(isPublic = true) {
            const stats = isPublic ? publicLeaderboardData : privateLeaderboardData;
            const state = isPublic ? sortState.public : sortState.private;
            const tbodyId = isPublic ? 'leaderboard-body' : 'private-leaderboard-body';
            const headerRowId = isPublic ? 'public-leaderboard-header' : 'private-leaderboard-header';
            
            const tbody = document.getElementById(tbodyId);
            const headerRow = document.getElementById(headerRowId);
            
            if (!tbody || !headerRow) return;

            // 1. Render Headers
            const columns = [
                { id: 'name', label: 'ç©å®¶' },
                { id: 'score', label: 'ç»¼åˆè¯„åˆ†' },
                { id: 'totalPnL', label: 'æ€»ç›ˆäº (CNY)' },
                { id: 'avgPnL', label: 'å¹³å‡ç›ˆäº' },
                { id: 'winRate', label: 'èƒœç‡ (%)' },
                { id: 'volatility', label: 'æ³¢åŠ¨ç‡' },
                { id: 'sharpe', label: 'Sharpe' },
                { id: 'maxLosingStreak', label: 'æœ€å¤§è¿äº' },
                { id: 'totalSessions', label: 'æ€»å±€æ•°' }
            ];

            headerRow.innerHTML = columns.map(col => {
                let sortIcon = '';
                let activeClass = '';
                if (state.column === col.id) {
                    sortIcon = state.direction === 'asc' ? 'â¬†ï¸' : 'â¬‡ï¸';
                    activeClass = 'active-sort';
                }
                const align = col.id === 'name' ? 'text-left' : (col.id === 'totalSessions' ? 'text-center' : 'text-right');
                // Use a string for isPublic in onclick to avoid JS errors
                return `<th class="p-3 ${align} text-xs font-medium uppercase tracking-wider sortable ${activeClass}" onclick="toggleSort('${isPublic}', '${col.id}')">
                    ${col.label} <span class="sort-icon">${sortIcon}</span>
                </th>`;
            }).join('');

            if (stats.length === 0) {
                tbody.innerHTML = `<tr><td colspan="9" class="p-4 text-center text-gray-400">æš‚æ— æ•°æ®ã€‚</td></tr>`;
                return;
            }

            // 2. Sort Data
            stats.sort((a, b) => {
                let valA = a[state.column];
                let valB = b[state.column];

                // Handle Infinity
                if (!isFinite(valA)) valA = valA > 0 ? Number.MAX_VALUE : -Number.MAX_VALUE;
                if (!isFinite(valB)) valB = valB > 0 ? Number.MAX_VALUE : -Number.MAX_VALUE;

                if (state.direction === 'asc') return valA > valB ? 1 : -1;
                else return valA < valB ? 1 : -1;
            });

            // 3. Render Rows
            // Normalize scores for display to be 0-100 range relative to the current set if needed, 
            // but calculateCompositeScores already does a decent job. 
            // We just scale them to look nice relative to each other.
            
            // Find score range to color code
            const maxScore = Math.max(...stats.map(s => s.score));
            const minScore = Math.min(...stats.map(s => s.score));

            tbody.innerHTML = '';
            stats.forEach(s => {
                const pnlClass = s.totalPnL > 0.01 ? 'text-win' : s.totalPnL < -0.01 ? 'text-loss' : 'text-neutral';
                let sharpeText = isFinite(s.sharpe) ? s.sharpe.toFixed(2) : 'N/A';
                if (s.sharpe === Infinity) sharpeText = 'âˆ';
                
                // Score styling
                // Map score to 0-100 for display if not already
                let displayScore = Math.round(50 + s.score); // Shift base to 50
                if (displayScore > 99) displayScore = 99;
                if (displayScore < 10) displayScore = 10;
                
                let scoreColor = 'bg-gray-700 text-gray-300';
                if (displayScore >= 80) scoreColor = 'bg-purple-900 text-purple-200 border border-purple-500';
                else if (displayScore >= 60) scoreColor = 'bg-green-900 text-green-200 border border-green-500';
                else if (displayScore < 40) scoreColor = 'bg-red-900 text-red-200 border border-red-500';

                tbody.innerHTML += `
                    <tr class="hover:bg-gray-800/70 transition-colors">
                        <td class="p-3 font-semibold">${s.name}</td>
                        <td class="p-3 text-right">
                            <span class="inline-block w-8 h-8 leading-8 text-center rounded-full text-xs font-bold ${scoreColor}">${displayScore}</span>
                        </td>
                        <td class="p-3 text-right ${pnlClass} font-bold">${s.totalPnL.toFixed(2)}</td>
                        <td class="p-3 text-right">${s.avgPnL.toFixed(2)}</td>
                        <td class="p-3 text-right">${s.winRate.toFixed(1)}%</td>
                        <td class="p-3 text-right">${s.volatility.toFixed(2)}</td>
                        <td class="p-3 text-right">${sharpeText}</td>
                        <td class="p-3 text-right text-loss">${s.maxLosingStreak}</td>
                        <td class="p-3 text-center">${s.totalSessions}</td>
                    </tr>
                `;
            });
        }
        
        // Utils
        function alertModal(title, message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `<div class="card p-6 rounded-xl w-full max-w-md"><h3 class="text-xl font-bold mb-3 text-white">${title}</h3><p class="text-gray-300 mb-4">${message}</p><button id="modal-ok-btn" class="btn-primary w-full p-3 rounded-lg font-semibold">ç¡®å®š</button></div>`;
            document.body.appendChild(modal);
            document.getElementById('modal-ok-btn').onclick = () => document.body.removeChild(modal);
        }
        
        window.onload = initializeFirebase;
    </script>
</body>
</html>